#!/usr/bin/env python
"""This module contains the core logic for the authenication server.
The server uses implements MAC Access Authentication."""

import httplib
import logging

import tornado.httpserver
import tornado.web

import strutil
import trhutil
import tsh

import async_creds_retriever
import async_nonce_checker
import async_hmac_auth
import async_app_server_forwarder
from clparser import CommandLineParser


_logger = logging.getLogger("AUTHSERVER.%s" % __name__)


"""When authentication fails and the auth server's logging is set
to a debug level responses will contain a series of HTTP headers
that provide additional detail on why the authentication failed.
All of theses header names are prefixed by the value of
```debug_header_prefix```.""" 
debug_header_prefix = "X-Auth-Server-"

auth_failure_detail_header_name = "%sAuth-Failure-Detail" % debug_header_prefix

"""```True``` if debug details should be generated by the async
authentication modules and those details then included in responses
to auth server requests."""
auth_failure_debug_details = False

class RequestHandler(trhutil.RequestHandler):

    def _on_app_server_done(
        self,
        is_ok,
        http_status_code=None,
        headers=None,
        body=None):

        if not is_ok:
            self.set_status(httplib.INTERNAL_SERVER_ERROR)
        else:
            self.set_status(http_status_code)
            for (name, value) in headers.items():
                self.set_header(name, value)
            if body is not None:
                self.write(body)
        self.finish()

    def _on_auth_done(
        self,
        is_auth_ok,
        auth_failure_detail=None,
        auth_failure_debug_details=None,
        owner=None,
        identifier=None):

        if not is_auth_ok:

            self.set_status(httplib.UNAUTHORIZED)

            if auth_failure_detail:
                self.set_header(
                    auth_failure_detail_header_name,
                    auth_failure_detail)

            if auth_failure_debug_details:
                for (name, value) in auth_failure_debug_details.items():
                    name = "%s%s" % (debug_header_prefix, name)
                    value = strutil.make_http_header_value_friendly(value)
                    self.set_header(name, value)

            self.finish()
            
            return

        aasf = async_app_server_forwarder.AsyncAppServerForwarder(
            self.request.method,
            self.request.uri,
            self.request.headers,
            self.get_request_body_if_exists(),
            owner,
            identifier)
        aasf.forward(self._on_app_server_done)

    def _handle_request(self):
        aha = async_hmac_auth.AsyncHMACAuth(
            self.request,
            auth_failure_debug_details)
        aha.authenticate(self._on_auth_done)

    @tornado.web.asynchronous
    def get(self):
        self._handle_request()

    @tornado.web.asynchronous
    def post(self):
        self._handle_request()

    @tornado.web.asynchronous
    def put(self):
        self._handle_request()

    @tornado.web.asynchronous
    def delete(self):
        self._handle_request()


_handlers = [(r".*", RequestHandler), ]
_app = tornado.web.Application(handlers=_handlers)


if __name__ == "__main__":
    clp = CommandLineParser()
    (clo, cla) = clp.parse_args()

    tsh.install_handler()

    logging.basicConfig(level=clo.logging_level)

    fmt = (
        "Auth Server listening on {clo.port} "
        "using Nonce Store {clo.nonce_store}, "
        "Key Server '{clo.app_server}' "
        "and App Server '{clo.app_server}'"
    )
    _logger.info(fmt.format(clo=clo))

    auth_failure_debug_details = _logger.isEnabledFor(logging.DEBUG)

    async_creds_retriever.key_server = clo.key_server
    async_hmac_auth.maxage = clo.maxage
    async_nonce_checker.nonce_store = clo.nonce_store
    async_app_server_forwarder.app_server = clo.app_server
    async_app_server_forwarder.auth_method = clo.app_server_auth_method

    http_server = tornado.httpserver.HTTPServer(_app)
    http_server.listen(clo.port)
    tornado.ioloop.IOLoop.instance().start()
